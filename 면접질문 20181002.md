## 면접질문 20181002



\1. 컴포넌트와 모듈의 차이

> 모듈은 가장 상위에 위치하는 구현의 단위, 컴포넌트는 런타임 개체를 참조하는 단위
>
>
>
> 모듈은 실질적으로 구현이 된 단위,
>
> 컴포넌트는 실제적으로 동작하고 있는 개체
>
>
>
> ex. 서버 클라이언트 구조에서 서버 1개와 클라이언트 100대가 있다면
>
> 구현된 모듈은 서버1, 클라이언트1 총 2개
>
> 동작하는 컴포넌트는 서버1개 클라이언트 100개 총 101개



\2. 자바란 무엇인가

> "Write once, Run anywhere" 라는 특성을 가진 완전 객체지향 언어



\3. 자바의 구동원리

> \1. 컴파일러를 통해 JAVA 코드 검증과 JVM이 이해할 수 있는 바이트코드(.CLASS)로 만듬
>
> \2. .CLASS를 찾아 JVM으로 가져옴
>
> \3. 바이트코드 검증
>
> \4. 인터프린트(재해석)
>
> \5. 바이트코드를 바이너리코드로 변경(바이너리 코드는 JVM의 클래스 영역에 저장)
>
> \6. 런타임 과정에서는 클래스들의 static  변수를 자동 초기화
>
> \7. static 블록 수행
>
> \8. 인스턴스 블록 수행
>
> \9. 생성자 호출
>
> \10. main 함수 호출



\4. JVM의 특징 

> \1. 스택기반의 가상머신
>
> \2. 가바지 컬렉션
>
> \3. 플랫폼에 독립적
>
>
>
> JAVA Compiler 이 java코드를 byte Code로 변환 -> Class Loadder System 을 통해 Class파일들을 JVM으로 로딩
>
> -> 로딩된 Class 파일들은 Execution Engine을 통해 해석됨 -> 해석된 프로그램은 Runtime Data Areas에 배치되어 실질적인 수행이 이루어짐 
>
> -> 실행과정속에서 JVM은 필요에 따라 Thread Synchronization 과 Garbage Collection 같은 관리 작업을 수행하게 됨



\5. 객체 지향과 절차지향의 차이점

> 절차지향
>
> \1. 루틴 서브루틴, 함수(프로시져) 등을 이용한 프로그래밍
>
> \2. 절차적으로 실행되는 것(X) -> 프로시져 콜, 즉 함수 호출을 통해서 재사용성을 얻어내는 것이 본질!
>
> \3. 장점 : 함수를 통한 코드의 재활용성 , 모듈화와 구조화에 용이함
>
> \4. 단점 : 프로시저 호출에 자원 낭비(최근 컴파일러, 하드웨어 성능향상으로 거의 상관없음)
>
>
>
> 객체지향
>
> \1. 프로그램을 단순히 데이터와 처리 방법으로 나누는 것이 아니라, 프로그램을 수많은 '객체'라는 기본 단위로 나누고 이 객체들의 상호작용ㅇ으로 서술하는 방식
>
> \2. 캡슐화, 상속, 다형성, 추상화 의 특징을 가짐
>
> \3. 장단점 : 상속(편리하지만 구조가 이상하게 변할 수있음), 인스턴스에 데이터 접근 불가, 새로운 데이터 형식을 정의할 수 있게 해줌



\6. 객체지향 언어의 특징

> \1. 캡슐화 : 객체의 속성(data fields)과 행위(methods)를 하나로 묶고 실제 구현 내용 일부를 외부에 감추어 은닉한다.
>
> \2. 상속 : 새로운 클래스가 기존의클래스의 자료와 연산을 이용할 수 있게 하는 기능이다.
>
> \3. 다형성 : 어떤 한 요소에 여러 개념을 넣어 놓은 것(오버라이딩, 오버로딩)
>
> \4. 추상화 : 공통의 속성이나 기능을 묶어 이름을 붙이는 것



\7. 상속과 구현의 차이점 과 특징 및 장단점

> \1. 상속 : is-a 관계(태생부터 무엇인가 기질을 타고 난 경우)
>
> \2. (인터페이스)구현 : can-do 관계(후천적인 형질)
>
>
>
> 장점 : 코드의 중복이 없음, 메소드 오버라이드를 통한 확장, 인터페이스 공유를 통한 다형성 구현
>
> 단점 : 다중상속을 통한 복잡성 증가(다이아몬드 형태)



\8. 오버라이딩 오버로딩의 차이점과 특징 

> 오버라이딩 : 부모 클래스 함수의 재정의 (함수이름, 매게변수, 반환형 그대로)
>
> 오버로딩 : 함수의 재정의(함수이름만 동일하고 나머진 달라도 괜춘)



\9. 기본형 변수와 참조형 변수가 뭐가있나 

> | 기본형 Primitive type  | 논리형                            | **boolean** 1btye |                 |                  |      |
> | ---------------------- | --------------------------------- | ----------------- | --------------- | ---------------- | ---- |
> | 문자형                 |                                   | **char** 2byte    |                 |                  |      |
> | 정수형                 | **byte** 1byte                    | **short** 2byte   | **int** 4byte   | **long** 8byte   |      |
> | 실수형                 |                                   |                   | **float** 4byte | **double** 8byte |      |
> | 참조형  Reference type | 기본형을 제외한 나머지 타입 4byte |                   |                 |                  |      |





\10. 스택오버 플로우가 왜일어나나 

> 스택 포인터가 스택의 경계를 넘어설 때 일어난다.
>
> 스택 오버플로의 가장 흔한 원인은 상당히 깊거나 무한으로 이어지는 루프이다. 
>
>
>
> ex.
>
> int foo(){
>
> return foo();
>
> }



\11. 메모리 누수가 무엇인가

> 프로세스가 메모리 할당 후, 해제하지 않아서 생기는 소프트웨어 오류
>
> 프로세스를 장기간 동작시켜야 하는 서버 프로그램같은 소프트웨어들이 매우 위험함



\12. 메모리 누수를 막기위해 어떻게 해야하나

> 프로세스가 끝나는 시점에서 할당된 변수를 항상 제거



\13. static에 대해 설명해봐라 

> C(절차지향) 에서의 static 은 지역변수와 지역변수 둘의 성질을 함께 가짐
>
> 선언된 함수 내에서만 사용가능하지만 한번 초기화 되면 종료될때까지 메모리 공간에 존재함
>
>
>
> 객체지향에서의 static은 일반적으로 클래스 맴버라고 부른다. 그 이유는 클래스 내에 선언이 되어 클래스 기반으로 선언된 모든 객체들이 static맴버를 참조할 수 있기 때문이다.



\14. 싱글턴이 무엇인가 ? 디자인패턴을 아나 ?

> 싱글턴 패턴이란 생성된 하나의 인스턴스를 계속해서 사용하게 하고 새로운 인스턴스 생성을 방지하는 패턴이다.
>
>
>
>
>
> 디자인 패턴의 종류(출처 : <http://hyeonstorage.tistory.com/99>)
>
>
>
> \- 스트래티지 패턴 (strategy pattern)
>
> 교환 가능한 행동을 캡슐화하고 위임을 통해서 어떤 행동을 사용할지 결정한다.
>
>
>
>
>
> \- 옵저버 패턴 (observer pattern)
>
> 상태가 변경되면 다른 객체들한테 연락을 돌릴 수 있게 한다.
>
>
>
> \- 데코레이터 패턴 (decorator pattern)
>
> 객체를 감싸서 새로운 행동을 제공한다.
>
>
>
> \- 팩토리 패턴 (factory pattern)
>
> 생성할 구상 클래스를 서브클래스에서 결정한다.
>
>
>
> \- 추상 팩토리 패턴 (AbstractFactory pattern)
>
> 클라이언트에서 구상 클래스를 지정하지 않으면서도 일군의 객체를 생성할 수 있도록 한다.
>
>
>
> \- 싱글턴 패턴 (singleton pattern)
>
> 딱 한 객체만 생성되도록 한다.
>
>
>
> \- 커맨드 패턴 (command pattern)
>
> 요청을 객체로 감싼다.
>
>
>
> \- 어댑터 패턴 (adaptor pattern)
>
> 객체를 감싸서 다른 인터페이스를 제공한다.
>
>
>
> \- 퍼사드 패턴 (facade pattern)
>
> 일련의 클래스에 대해서 간단한 인터페이스를 제공한다.
>
>
>
> \- 템플릿 메소드 패턴 (template method pattern)
>
> 알고리즘의 개별 단계를 구현하는 방법을 서브클래스에서 결정한다.
>
>
>
> \- 이터레이터 패턴 (iterator pattern)
>
> 컬렉션이어떤 식으로 구현되었는지 드러내진 않으면서도 컬렉션 내에 있는 모든 객체에 대해 반복 작업을 처리할 수 있게 한다.
>
>
>
> \- 컴포지트 패턴 (composite pattern)
>
> 클라이언트에서 객체 컬렉션과 개발 객체를 똑같이 다룰 수 있도록 한다.
>
>
>
> \- 스테이트 패턴 (state pattern)
>
> 알고리즘의 개별 단계를 구현하는 방법을 서브클래스에서 결정한다.
>
>
>
> \- 프록시 패턴 (proxy pattern)
>
> 객체를 감싸서 그 객체에 대한 접근을 제어한다.
>
>
>
> \- 컴파운드 패턴 (compound pattern)
>
> 반복적으로 생길 수 있는 일반적인 문제를 해결하기 위한 용도로 두 개 이상의 패턴을 결합해서 사용한는 것
>
>
>
> \- 브리지 패턴 (bridge pattern)
>
> 구현 뿐만 아니라 추상화된 부분까지 변경시켜야 하는 경우
>
>
>
> \- 빌더 패턴 (builder pattern)
>
> 제품을 여러 단계로 나눠서 만들 수 있도록 제품 생산 단계들을 캡슐화할 때
>
>
>
> \- 역할 사슬 패턴 (chain of responsibility pattern)
>
> 한 요청을 두 개 이상의 객체에서 처리하고 싶을 때
>
>
>
> \- 플라이웨이트 패턴 (flyweight pattern)
>
> 어떤 클래스의 인스턴스 한 개만가지고 여러 개의 "가상 인스턴스"를 제공하고 싶을 때
>
>
>
> \- 인터프리터 패턴 (Interpreter pattern)
>
> 어떤 언어에 대한 인터프리터를 만들 때
>
>
>
> \- 미디에이터 패턴 (mediator pattern)
>
> 서로 관련된 객체 사이의 복잡한 통신과 제어를 한 곳으로 집중시키고자 할 때
>
>
>
> \- 메멘토 패턴 (memento pattern) 
>
> 객체를 이전의 상태로 복구시켜야 하는 경우
>
>
>
> \- 프로토타입 패턴 (prototype pattern)
>
> 어떤 클래스의 인스턴스를 만드는 것이 자원/시간을 많이 잡아먹거나 복잡한 경우
>
>
>
> \- 비지터 패턴 (visitor pattern)
>
> 다양한 객체에 새로운 기능을 추가해야 하는데 캡슐화가 별로 중요하지 않은 경우자인 상의 문제를 간편하게 적용해서 쓸 수 있게 패턴 형태로 만든 것.



\15. 익명클래스와 익명객체를 아나?

> 익명 클래스란 '이름이 없는 클래스'를 가르킨다.
>
> 클래스의 선언과 객체의 생성을 동시에 진행 -> 한번만 사용될 수 있고, 하나의 객체만을 만듬
>
>
>
> ex
>
> Object obj = new Object(){
>
> void method()
>
> {
>
> }
>
> };

