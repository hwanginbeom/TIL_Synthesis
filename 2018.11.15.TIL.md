

### 2018.11.06.TIL





#### 스택(stack) 

자료의 입력과 출력을 한 곳(방향)으로 제한한 자료 구조.

LIFO(LAST in First Out)구조 push(), pop()

함수의 콜스택에 쓰이고 문자열을 역순으로 출력할 때, 연산자 후위 표기법등에 쓰인다.

- 활용예시

   

  : 후입선출(LIFO)의 특징을 활용하여 여러 분야에서 활용 가능하다.

  - 웹 브라우저 방문기록 (뒤로가기)
  - 실행취소 (undo)
  - 역순 문자열 만들기
  - 수식의 괄호 검사 (연산자 우선순위 표현을 위한 괄호 검사)
  - 후위표기법 계산

###  

1. 

   ```
   #ifndef CIRCULARQUEUE_H_
   #define CIRCULARQUEUE_H_
    
   #define TRUE     1
   #define FALSE    0
    
   #define QUE_LEN  100
    
   typedef struct _cQueue
   {
       int front;                       // 삭제할 데이터의 위치를 가리키는 변수
       int rear;                        // 삽입할 데이터의 위치를 가리키는 변수
       int queArr[QUE_LEN];             // QUE_LEN 길이를 갖는 큐 배열
   } CQueue;
    
   typedef CQueue Queue;
    
   void QueueInit(Queue * pq);          // 큐 초기화 함수
   int QIsEmpty(Queue * pq);            // 큐에 데이터가 존재하는지 확인하는 함수
    
   void Enqueue(Queue * pq, int data);  // 큐에 데이터를 저장하는 함수
   int Dequeue(Queue * pq);             // 큐의 데이터를 반환하는 함수
   int QPeek(Queue * pq);               // 큐의 데이터를 조회하는 함수
    
   #endif
   
   
   출처: http://creativeprm.tistory.com/305 [Creative Programmer]
   ```











#### 큐(queue)



자료의 입력과 출력을 한 쪽 끝(front,rear)으로 제한한 자료구조.

FIFO(First in First Out)구조 put(), get()

컴퓨터 버퍼에서 주로 사용 , 마구 입력이 되었으나 처리를 하지 못 할 때, 버퍼(큐)를 만들어 대기 시킨다.

일반적인 큐의 단점 : 큐에 빈 메모리가 남아 있어도 꽉 차있는 것으로 판단 할 수 있음 rear가 배열의 끝에 도달했을 경우. 

=>개선된 원형 큐가 나옴

원형 큐의 단점 : 메모리 공간은 잘 활용하나 배열로 구현되어 있기 때문에 큐의 크기가 제한되는 단점이 존재 

=>링크드리스트로 큐가 나옴

링크드 리스트으로 구현한 큐는 큐의 크기가 제한이 없고 삽입,삭제가 편리하다.



활용예시

 :선입선출(FIFO)의 특징을 활용한 활용예시

- 우선순위가 같은 작업 예약 (인쇄 대기열)

- 선입선출이 필요한 대기열 (티켓 카운터)

- 콜센터 고객 대기시간




#### 덱(deque)

자료의 입력과 출력을 양 쪽 끝에서 가능하게 하는 자료구조

스크롤(scroll) : 입력이 한 쪽 끝으로만 가능하도록 제한한 덱

셸프(shelf): 출력이 한 쪽 끝으로만 가능하도록 제한한 덱





### 해시 테이블

- 해시 테이블은 사전을 구현하는 가장 효율적인 자료구조이다.
- 이론적으로는 해시 테이블에서 원소를 찾는 것이 연결 리스트에서 원소를 찾는 것 (O(n)) 만큼 오래 걸릴 수 있지만, 실제 해싱은 성능이 탁월하다.
- 일반적으로 해시 테이블에서 원소를 찾는 데 걸리는 수행시간은 O(1)이다.
- 해시 테이블은 단순한 표현인 배열을 일반화 한 것이다.
- 일반적인 배열에 대한 직접 번지화 방법은 배열의 임의의 위치를 O(1)안에 접근하게 하는 효율적인 방법이다.





### 디자인 패턴이란?

소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 할 수있는 훌륭한 해결책





#### 싱글톤 패턴(Singleton Pattern)

애플리케이션이 시작 될 떄 클래스가 최초 한번만 메모리를 할당하고 (Static) 그 메모리에 인스턴스를 만들어 사용 하는 디자인 패턴 

생성자가 여러 차례 호출 되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.

=>싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용 하는 디자인 패턴 이다. 



#### 장점

고정된 메모리 영역을 얻으면서 한번의 new 로 인스턴스를 사용하기 때 문에 메모리 낭비를 방지할 수 있음 (인스턴스 - 클래스에 정의된 변수 )

ex) 쓰레드풀 , 캐시 , 대화상자, 사용자 설정, 레지스트리 설정 , 로그 기록 객체



#### 단점 

많은 데이터를 공유 시킬 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 개방-폐쇄 원칙을 위반하게 된다 ( 객체 지향 설계원칙에 어긋남 )

수정이 어려워지고 테스트 하기 어려워 진다. / 동기화 처리를 안하면 인스턴스가 두개가 생성되는 경우가 생길 수도 있음 !



### MVC 패턴

MVC란 **M**odel **V**iew **C**ontroller의 약자로 에플리케이션을 세가지의 역할로 구분한 개발 방법론이다. 아래의 그림처럼 사용자가 Controller를 조작하면 Controller는 Model을 통해서 데이터를 가져오고 그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 사용자에게 전달하게 된다. 

![img](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/327/1262.png)



### Controller

사용자가 접근 한 URL에 따라서 사용자의 요청사항을 파악한 후에 그 요청에 맞는 데이터를 Model에 의뢰하고, 데이터를 View에 반영해서 사용자에게 알려준다. 

### Model

일반적으로 CI의 모델은 데이터베이스 테이블에 대응된다. 이를테면 Topic이라는 테이블은 topic_model이라는 Model을 만든다. 그런데 이 관계가 강제적이지 않기 때문에 규칙을 일관성 있게 정의하는 것이 필요하다.

#### View

View는 클라이언트 측 기술인 html/css/javascript들을 모아둔 컨테이너이다. 



。클래스와 객체

  \- 클래스는 설계도라 생각하면 됩니다.

​     객체는 사물 또는 개념이라 생각하시면 됩니다.

​    

​     "자동차" 로 예를 들겠습니다.

  

### 클래스와 객체

   **자동차설계도(클래스)는 자동차(객체)를 정의한 것이며, 자동차(객체)를 만드는 데 사용한다****.**

 

​     자동차를 타기 위해서 자동차(객체)가 필요하다 그러나 자동차설계도(클래스)가 필요하진 않다.

​     자동차설계도(클래스)는 단지 자동차(객체)를 만드는데만 사용될 뿐이다. 자동차설계도(클래스)

​     를 통해 자동차(객체)가 만들어 진 후에 사용할 수 있는 것이다.

​     즉, 프로그래밍에서 클래스를 먼저 작성한 다음 객체를 생성하여 사용한다.

 

​     객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있다. 객체는 속성과 기능의 집합이라 할 수 있다.

​     객체가 가지고 있는 속성과 그 기능을 객체의 맴버라 한다.

 

​     클래스란 객체를 정의한 것으로 클래스에는 객체의 모든 속성과 기능이 정의되어있다.

​     클래스로 부터 객체를 생성하면, 클래스에 정의된 속성과 기능을 가진 객체가 만들어 지는 것이다.

​      

​     다시 자동차로 예를 들어자. 자동차의 속성으로는 브레이크,악셀,색상 등이 있으며, 기능으로는 브레이크 밟기, 악셀밟기

​     전진하기, 후진하기 등이 있다.

​    

​     자바에서는 속성과 기능을 변수와 함수로 표현한다.

​     속성 -> 멤버변수,   기능 -> 메소드   

​    



#### 추상 클래스 vs 인터페이스

추상 클래스  - 클래스 내 추상메소드가 하나 이상 포함되거나 abstract로 정의된 경우 

​			추상 클래스를 상속 받아서 기능을 이용하고, 확장 시키는데 있다.



인터페이스 - 모든 메소드가 추상 메소드인 경우 / 함수의 껍데기만 존재 -> 함수의 구현을 강제하기 위해서

​			구현을 강제함으로써 구현 객체의 같은 동작을 보장 



추상 클래스와 인터페이스는 상속받는 클래스 혹은 구현하는 인터페이스 안에 있는 추상 메소드 구현하도록 강제



자바는 다중 상속을 지원하지 않는다 . 





#### JAVA와 PYTHON의 차이 



> 변수 - 세미콜론 사용 유무  / 자료형 유무

우선 변수를 선언하는 방법이 다릅니다. Java의 변수를 선언할 때 데이터 형태를 반드시 정해줘야 하지만 Python의 경우 자료형을 쓰지 않아도 가능하네요.

  int a = 100;
String b = "Java";

a = 100
b = "python"



> 문장의 끝

Java의 경우 문장을 마칠 때 반드시 ;(세미콜론)을 써야 하지만 Python은 쓰지 않아도 되네요.



> 주석

Java의 경우 한 문장은 //으로 복수의 문장의 경우 /*  */로 주석 처리를 하지만 Python의 경우 한 문자은 [#으로](https://m.blog.naver.com/BlogTagView.nhn?blogId=magnking&pushNavigation=true&tagName=%EC%9C%BC%EB%A1%9C) 복수의 문장은 '''   '''로 표시를 하네요.



> 문자열과 숫자의 결합

Java의 경우 문자열과 숫자가 결합하면 숫자가 자동으로 문자열로 변환되지만 Python의 경우 str()함수를 써줘야 에러가 나지 않습니다.



> 메소드 vs 함수

필요한 기능을 정의하는 문법 요소를  Java에서는 메소드라고 부르고 Python에서는 함수라고 부르네요.



> import 후의 사용법

Java의 경우 패키지를 import 했다고 이야기하는데 Python의 경우 모듈을 import했다고 이야기 하는 것 같습니다. 그리고 import 후의 사용 방법도 다릅니다.  Java의 경우 패키지를 import한 후 변수를 선언하고 인스턴스를 생성한 후 그 변수에「.」(피리오드)를 쓰고 메소드 명을 써서 함수를 호출하는데 Python의 경우 모듈에 바로 「.」(피리오드)를 쓰고 함수를 호출해서 사용하네요.



> if문

Java에서 쓰이는 if문과 python에서 쓰는 if 문의 쓰임은 거의 같으나 쓰는 방식이 다릅니다. Java의 경우 if를 쓴 후 ()(소괄호) 안에 조건을 넣고 조건문 블록을 {}(중괄호)로 구별하지만 Python의 경우 조건문 뒤에 :(콜론)을 씁니다. else문도 마찬가지인데 Java의 경우 블록을 {}(중괄호)로 구별하지만 Python의 경우 :(콜론)으로 구별합니다. 

if(number == 1){
​    println("당첨!");
}else{
​    println("꽝!");
}

if number == 1:
​    print("당첨")
else:
​    print("꽝")



> if문을 이용한 복수 조건 표현

if문을 이용하여 복수 조건을 표시하고자 할 때 Java의 경우 else if라는 명령어를 사용하지만 Python의 경우 elif라는 명령어를 사용합니다.

if(number == 1){
​    println("당첨!");
}else if(number == 2){
​    println("재추첨!");
}else{
​    println("꽝");
}

if number == 1:
​    print("당첨")
elif nummber == 2:
​    print("재퉆표")
else:
​    print("꽝")



> Boolean 타입 입력

Java의 경우 true, false 이렇게 소문자로 쓰고 Python의 경우 True, False 이렇게 대문자로 씁니다.



> 반복문의 형태(for)

Java에서는 for문이라고 쓰는데 Python에서는 for in을 사용합니다.

for(int i =0; i < 10; i++){
​    println(i+"사람");
}

for i in range(10):
​    print(str(i)+"사람")

> 반복문의 형태(while)

Java의 경우 while 옆에 괄호를 쓰고 괄호 안에 조건을 씁니다. 그러면 그 조건이 거짓이 될 때까지 반복이 됩니다.  Python의 경우는 while 옆에 바로 조건식을 쓰고 :(콜론)으로 조건의 종료를 표시합니다. 그리고 i = i +1과 같은 형식으로 카운터 변수의 증가를 조절해 주어야 합니다. 

while(i <= 5){
​    println(i+"명");
​    i = i +1
}

while i <= 5:
​    print(str(i) + "명")
​    i = i +1



> 배열

Java나 다른 컴퓨터 언어에서는 주로 배열로 불리는 기능이 Python에서는 리스트라는 이름으로 제공됩니다. Java의 경우 객체를 생성하고 인덱스를 통해서 자료를 넣어주어야 하고 또 자료형도 정해져 있습니다. 인덱스 없이 중괄호를 이용해서 바로 넣어주는 방법도 있습니다. Python의 경우에는 간단히 대괄호 안에 데이터를 넣어주면 되고 자료형을 정해줄 필요도 없고 서로 다른 자료형이 들어갈 수 있습니다. Python쪽이 압도적으로 편해보이네요. 왜 이런 차이가 발생한 것일까요?

int arr= new int[3];
​     arr[0] = 1;
​     arr[1] = 2;
​    arr[2] = 3;
int[] arr = {1, 2, 3};

list = [1, "이", "3"]





#### int 와 integer의 차이



**1. Primitive 자료형 - Wrapper 클래스 관계**



| **int**                                                      | **primitive 자료형 (long, float, double ...)** |
| ------------------------------------------------------------ | ---------------------------------------------- |
| 산술 연산이 가능하다.                                        |                                                |
| null로 초기화 할 수 없다.                                    |                                                |
| **Integer**                                                  | **Wrapper 클래스 (객체)**                      |
| Unboxing을 하지 않으면 산술 연산이 불가능 하지만, null 값을 처리할 수 있다. |                                                |
| null 값 처리가 용이하기 때문에 SQL과 연동할 경우 처리가 용이하다. |                                                |
| DB에서 자료형이 정수형이지만 null 값이 필요한 경우 VO에서 Integer를 사용할 수 있음. |                                                |







------





**2. int와 Integer간의 변환**

\- Boxing과 Unboxing이라고 한다.





| **Boxing**   | Primitive 자료형 -> Wrapper 클래스 |
| ------------ | ---------------------------------- |
| **Unboxing** | Wrapper 클래스 -> Primitive 자료형 |



\- 예제 코드



```
// to int i from Integer ii
int i = ii.intValue();

// to Integer ii from int i
Integer ii = new Integer( i );
```

\- valueOf()와 parseInt()의 차이



| **Integer.valueOf(String)**  | Integer 클래스를 리턴하기 때문에 산술 연산을 할 수 없다. |
| ---------------------------- | -------------------------------------------------------- |
| **Integer.parseInt(String)** | int 형을 리턴하기 때문에 산술 연산을 할 수 있다.         |



※ 정수로 파싱할 수 없는 String을 파라미터로 전달하면 에러



출처: 

http://includestdio.tistory.com/1

 [includestdio]





#### **닷넷(.NET)이란?** 

닷넷 프레임워크(.NET Framework)는 마이크로소프트사에서 제공하는 윈도우 프로그램 개발 및 실행환경입니다. 네트워크 작업, 인터페이스등의 많은 작업을 캡슐화하여 코딩의 효율성을 증대시켰습니다. .NET의 특징은 CLS(닷넷 프레임워크의 언어가 반드시 지켜야하는 언어 스펙)을 따르는 언어라면 어떠한 언어라도 닷넷 프레임워크에서 실행가능하며 CLR이라는 가상기계 위에서 작동하기 때문에 플랫폼에 독립적이며 궁극적으로 프로그래머가 코딩(특히 윈도우 프로그램)을 하는데 더 편한 환경을 제공해줍니다.



![.NET 프레임워크 구조](https://t1.daumcdn.net/cfile/tistory/999DDB465ADD30F31F).