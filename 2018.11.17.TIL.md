





#### 스택(stack) 

자료의 입력과 출력을 한 곳(방향)으로 제한한 자료 구조.

LIFO(LAST in First Out)구조 push(), pop()

함수의 콜스택에 쓰이고 문자열을 역순으로 출력할 때, 연산자 후위 표기법등에 쓰인다.

- 활용예시

   

  : 후입선출(LIFO)의 특징을 활용하여 여러 분야에서 활용 가능하다.

  - 웹 브라우저 방문기록 (뒤로가기)
  - 실행취소 (undo)
  - 역순 문자열 만들기
  - 수식의 괄호 검사 (연산자 우선순위 표현을 위한 괄호 검사)
  - 후위표기법 계산

###  

1. 

   ```
   #ifndef CIRCULARQUEUE_H_
   #define CIRCULARQUEUE_H_
    
   #define TRUE     1
   #define FALSE    0
    
   #define QUE_LEN  100
    
   typedef struct _cQueue
   {
       int front;                       // 삭제할 데이터의 위치를 가리키는 변수
       int rear;                        // 삽입할 데이터의 위치를 가리키는 변수
       int queArr[QUE_LEN];             // QUE_LEN 길이를 갖는 큐 배열
   } CQueue;
    
   typedef CQueue Queue;
    
   void QueueInit(Queue * pq);          // 큐 초기화 함수
   int QIsEmpty(Queue * pq);            // 큐에 데이터가 존재하는지 확인하는 함수
    
   void Enqueue(Queue * pq, int data);  // 큐에 데이터를 저장하는 함수
   int Dequeue(Queue * pq);             // 큐의 데이터를 반환하는 함수
   int QPeek(Queue * pq);               // 큐의 데이터를 조회하는 함수
    
   #endif
   
   
   출처: http://creativeprm.tistory.com/305 [Creative Programmer]
   ```











#### 큐(queue)



자료의 입력과 출력을 한 쪽 끝(front,rear)으로 제한한 자료구조.

FIFO(First in First Out)구조 put(), get()

컴퓨터 버퍼에서 주로 사용 , 마구 입력이 되었으나 처리를 하지 못 할 때, 버퍼(큐)를 만들어 대기 시킨다.

일반적인 큐의 단점 : 큐에 빈 메모리가 남아 있어도 꽉 차있는 것으로 판단 할 수 있음 rear가 배열의 끝에 도달했을 경우. 

=>개선된 원형 큐가 나옴

원형 큐의 단점 : 메모리 공간은 잘 활용하나 배열로 구현되어 있기 때문에 큐의 크기가 제한되는 단점이 존재 

=>링크드리스트로 큐가 나옴

링크드 리스트으로 구현한 큐는 큐의 크기가 제한이 없고 삽입,삭제가 편리하다.



활용예시

 :선입선출(FIFO)의 특징을 활용한 활용예시

- 우선순위가 같은 작업 예약 (인쇄 대기열)

- 선입선출이 필요한 대기열 (티켓 카운터)

- 콜센터 고객 대기시간




#### 덱(deque)

자료의 입력과 출력을 양 쪽 끝에서 가능하게 하는 자료구조

스크롤(scroll) : 입력이 한 쪽 끝으로만 가능하도록 제한한 덱

셸프(shelf): 출력이 한 쪽 끝으로만 가능하도록 제한한 덱





### 해시 테이블

- 해시 테이블은 사전을 구현하는 가장 효율적인 자료구조이다.
- 이론적으로는 해시 테이블에서 원소를 찾는 것이 연결 리스트에서 원소를 찾는 것 (O(n)) 만큼 오래 걸릴 수 있지만, 실제 해싱은 성능이 탁월하다.
- 일반적으로 해시 테이블에서 원소를 찾는 데 걸리는 수행시간은 O(1)이다.
- 해시 테이블은 단순한 표현인 배열을 일반화 한 것이다.
- 일반적인 배열에 대한 직접 번지화 방법은 배열의 임의의 위치를 O(1)안에 접근하게 하는 효율적인 방법이다.





### 디자인 패턴이란?

소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 때 재사용할 할 수있는 훌륭한 해결책





#### 싱글톤 패턴(Singleton Pattern)

애플리케이션이 시작 될 떄 클래스가 최초 한번만 메모리를 할당하고 (Static) 그 메모리에 인스턴스를 만들어 사용 하는 디자인 패턴 

생성자가 여러 차례 호출 되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.

=>싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용 하는 디자인 패턴 이다. 



#### 장점

고정된 메모리 영역을 얻으면서 한번의 new 로 인스턴스를 사용하기 때 문에 메모리 낭비를 방지할 수 있음 (인스턴스 - 클래스에 정의된 변수 )

ex) 쓰레드풀 , 캐시 , 대화상자, 사용자 설정, 레지스트리 설정 , 로그 기록 객체



#### 단점 

많은 데이터를 공유 시킬 경우 다른 클래스의 인스턴스들 간에 결합도가 높아져 개방-폐쇄 원칙을 위반하게 된다 ( 객체 지향 설계원칙에 어긋남 )

수정이 어려워지고 테스트 하기 어려워 진다. / 동기화 처리를 안하면 인스턴스가 두개가 생성되는 경우가 생길 수도 있음 !



### MVC 패턴

MVC란 **M**odel **V**iew **C**ontroller의 약자로 에플리케이션을 세가지의 역할로 구분한 개발 방법론이다. 아래의 그림처럼 사용자가 Controller를 조작하면 Controller는 Model을 통해서 데이터를 가져오고 그 정보를 바탕으로 시각적인 표현을 담당하는 View를 제어해서 사용자에게 전달하게 된다. 

![img](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/327/1262.png)



### Controller

사용자가 접근 한 URL에 따라서 사용자의 요청사항을 파악한 후에 그 요청에 맞는 데이터를 Model에 의뢰하고, 데이터를 View에 반영해서 사용자에게 알려준다. 

### Model

일반적으로 CI의 모델은 데이터베이스 테이블에 대응된다. 이를테면 Topic이라는 테이블은 topic_model이라는 Model을 만든다. 그런데 이 관계가 강제적이지 않기 때문에 규칙을 일관성 있게 정의하는 것이 필요하다.

#### View

View는 클라이언트 측 기술인 html/css/javascript들을 모아둔 컨테이너이다. 



。클래스와 객체

  \- 클래스는 설계도라 생각하면 됩니다.

​     객체는 사물 또는 개념이라 생각하시면 됩니다.

​    

​     "자동차" 로 예를 들겠습니다.

  

### 클래스와 객체

   **자동차설계도(클래스)는 자동차(객체)를 정의한 것이며, 자동차(객체)를 만드는 데 사용한다****.**

 

​     자동차를 타기 위해서 자동차(객체)가 필요하다 그러나 자동차설계도(클래스)가 필요하진 않다.

​     자동차설계도(클래스)는 단지 자동차(객체)를 만드는데만 사용될 뿐이다. 자동차설계도(클래스)

​     를 통해 자동차(객체)가 만들어 진 후에 사용할 수 있는 것이다.

​     즉, 프로그래밍에서 클래스를 먼저 작성한 다음 객체를 생성하여 사용한다.

 

​     객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있다. 객체는 속성과 기능의 집합이라 할 수 있다.

​     객체가 가지고 있는 속성과 그 기능을 객체의 맴버라 한다.

 

​     클래스란 객체를 정의한 것으로 클래스에는 객체의 모든 속성과 기능이 정의되어있다.

​     클래스로 부터 객체를 생성하면, 클래스에 정의된 속성과 기능을 가진 객체가 만들어 지는 것이다.

​      

​     다시 자동차로 예를 들어자. 자동차의 속성으로는 브레이크,악셀,색상 등이 있으며, 기능으로는 브레이크 밟기, 악셀밟기

​     전진하기, 후진하기 등이 있다.

​    

​     자바에서는 속성과 기능을 변수와 함수로 표현한다.

​     속성 -> 멤버변수,   기능 -> 메소드   

​    



#### 추상 클래스 vs 인터페이스

추상 클래스  - 클래스 내 추상메소드가 하나 이상 포함되거나 abstract로 정의된 경우 

​			추상 클래스를 상속 받아서 기능을 이용하고, 확장 시키는데 있다.



인터페이스 - 모든 메소드가 추상 메소드인 경우 / 함수의 껍데기만 존재 -> 함수의 구현을 강제하기 위해서

​			구현을 강제함으로써 구현 객체의 같은 동작을 보장 



추상 클래스와 인터페이스는 상속받는 클래스 혹은 구현하는 인터페이스 안에 있는 추상 메소드 구현하도록 강제



자바는 다중 상속을 지원하지 않는다 . 





#### JAVA와 PYTHON의 차이 



> 변수 - 세미콜론 사용 유무  / 자료형 유무

우선 변수를 선언하는 방법이 다릅니다. Java의 변수를 선언할 때 데이터 형태를 반드시 정해줘야 하지만 Python의 경우 자료형을 쓰지 않아도 가능하네요.

  int a = 100;
String b = "Java";

a = 100
b = "python"



> 문장의 끝

Java의 경우 문장을 마칠 때 반드시 ;(세미콜론)을 써야 하지만 Python은 쓰지 않아도 되네요.



> 주석

Java의 경우 한 문장은 //으로 복수의 문장의 경우 /*  */로 주석 처리를 하지만 Python의 경우 한 문자은 [#으로](https://m.blog.naver.com/BlogTagView.nhn?blogId=magnking&pushNavigation=true&tagName=%EC%9C%BC%EB%A1%9C) 복수의 문장은 '''   '''로 표시를 하네요.



> 문자열과 숫자의 결합

Java의 경우 문자열과 숫자가 결합하면 숫자가 자동으로 문자열로 변환되지만 Python의 경우 str()함수를 써줘야 에러가 나지 않습니다.



> 메소드 vs 함수

필요한 기능을 정의하는 문법 요소를  Java에서는 메소드라고 부르고 Python에서는 함수라고 부르네요.



> import 후의 사용법

Java의 경우 패키지를 import 했다고 이야기하는데 Python의 경우 모듈을 import했다고 이야기 하는 것 같습니다. 그리고 import 후의 사용 방법도 다릅니다.  Java의 경우 패키지를 import한 후 변수를 선언하고 인스턴스를 생성한 후 그 변수에「.」(피리오드)를 쓰고 메소드 명을 써서 함수를 호출하는데 Python의 경우 모듈에 바로 「.」(피리오드)를 쓰고 함수를 호출해서 사용하네요.



> if문

Java에서 쓰이는 if문과 python에서 쓰는 if 문의 쓰임은 거의 같으나 쓰는 방식이 다릅니다. Java의 경우 if를 쓴 후 ()(소괄호) 안에 조건을 넣고 조건문 블록을 {}(중괄호)로 구별하지만 Python의 경우 조건문 뒤에 :(콜론)을 씁니다. else문도 마찬가지인데 Java의 경우 블록을 {}(중괄호)로 구별하지만 Python의 경우 :(콜론)으로 구별합니다. 

if(number == 1){
​    println("당첨!");
}else{
​    println("꽝!");
}

if number == 1:
​    print("당첨")
else:
​    print("꽝")



> if문을 이용한 복수 조건 표현

if문을 이용하여 복수 조건을 표시하고자 할 때 Java의 경우 else if라는 명령어를 사용하지만 Python의 경우 elif라는 명령어를 사용합니다.

if(number == 1){
​    println("당첨!");
}else if(number == 2){
​    println("재추첨!");
}else{
​    println("꽝");
}

if number == 1:
​    print("당첨")
elif nummber == 2:
​    print("재퉆표")
else:
​    print("꽝")



> Boolean 타입 입력

Java의 경우 true, false 이렇게 소문자로 쓰고 Python의 경우 True, False 이렇게 대문자로 씁니다.



> 반복문의 형태(for)

Java에서는 for문이라고 쓰는데 Python에서는 for in을 사용합니다.

for(int i =0; i < 10; i++){
​    println(i+"사람");
}

for i in range(10):
​    print(str(i)+"사람")

> 반복문의 형태(while)

Java의 경우 while 옆에 괄호를 쓰고 괄호 안에 조건을 씁니다. 그러면 그 조건이 거짓이 될 때까지 반복이 됩니다.  Python의 경우는 while 옆에 바로 조건식을 쓰고 :(콜론)으로 조건의 종료를 표시합니다. 그리고 i = i +1과 같은 형식으로 카운터 변수의 증가를 조절해 주어야 합니다. 

while(i <= 5){
​    println(i+"명");
​    i = i +1
}

while i <= 5:
​    print(str(i) + "명")
​    i = i +1



> 배열

Java나 다른 컴퓨터 언어에서는 주로 배열로 불리는 기능이 Python에서는 리스트라는 이름으로 제공됩니다. Java의 경우 객체를 생성하고 인덱스를 통해서 자료를 넣어주어야 하고 또 자료형도 정해져 있습니다. 인덱스 없이 중괄호를 이용해서 바로 넣어주는 방법도 있습니다. Python의 경우에는 간단히 대괄호 안에 데이터를 넣어주면 되고 자료형을 정해줄 필요도 없고 서로 다른 자료형이 들어갈 수 있습니다. Python쪽이 압도적으로 편해보이네요. 왜 이런 차이가 발생한 것일까요?

int arr= new int[3];
​     arr[0] = 1;
​     arr[1] = 2;
​    arr[2] = 3;
int[] arr = {1, 2, 3};

list = [1, "이", "3"]





#### int 와 integer의 차이



**1. Primitive 자료형 - Wrapper 클래스 관계**



| **int**                                                      | **primitive 자료형 (long, float, double ...)** |
| ------------------------------------------------------------ | ---------------------------------------------- |
| 산술 연산이 가능하다.                                        |                                                |
| null로 초기화 할 수 없다.                                    |                                                |
| **Integer**                                                  | **Wrapper 클래스 (객체)**                      |
| Unboxing을 하지 않으면 산술 연산이 불가능 하지만, null 값을 처리할 수 있다. |                                                |
| null 값 처리가 용이하기 때문에 SQL과 연동할 경우 처리가 용이하다. |                                                |
| DB에서 자료형이 정수형이지만 null 값이 필요한 경우 VO에서 Integer를 사용할 수 있음. |                                                |







------





**2. int와 Integer간의 변환**

\- Boxing과 Unboxing이라고 한다.





| **Boxing**   | Primitive 자료형 -> Wrapper 클래스 |
| ------------ | ---------------------------------- |
| **Unboxing** | Wrapper 클래스 -> Primitive 자료형 |



\- 예제 코드



```
// to int i from Integer ii
int i = ii.intValue();

// to Integer ii from int i
Integer ii = new Integer( i );
```

\- valueOf()와 parseInt()의 차이



| **Integer.valueOf(String)**  | Integer 클래스를 리턴하기 때문에 산술 연산을 할 수 없다. |
| ---------------------------- | -------------------------------------------------------- |
| **Integer.parseInt(String)** | int 형을 리턴하기 때문에 산술 연산을 할 수 있다.         |



※ 정수로 파싱할 수 없는 String을 파라미터로 전달하면 에러



출처: 

http://includestdio.tistory.com/1

 [includestdio]





#### **닷넷(.NET)이란?** 

닷넷 프레임워크(.NET Framework)는 마이크로소프트사에서 제공하는 윈도우 프로그램 개발 및 실행환경입니다. 네트워크 작업, 인터페이스등의 많은 작업을 캡슐화하여 코딩의 효율성을 증대시켰습니다. .NET의 특징은 CLS(닷넷 프레임워크의 언어가 반드시 지켜야하는 언어 스펙)을 따르는 언어라면 어떠한 언어라도 닷넷 프레임워크에서 실행가능하며 CLR이라는 가상기계 위에서 작동하기 때문에 플랫폼에 독립적이며 궁극적으로 프로그래머가 코딩(특히 윈도우 프로그램)을 하는데 더 편한 환경을 제공해줍니다.



![.NET 프레임워크 구조](https://t1.daumcdn.net/cfile/tistory/999DDB465ADD30F31F)



#### 기본 정렬 알고리즘 ( 선택 , 삽입 , 버블 , 합병)

해쉬알고리즘 









### **자바의 장점**

**1.객체지향 언어**

\- 객체 지향 프로그래밍([영어](https://ko.wikipedia.org/wiki/%EC%98%81%EC%96%B4): Object-Oriented Programming, OOP)은 컴퓨터 프로그래밍의 패러다임의 하나이다

\- 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.

\- 프로그래밍을 더 배우기 쉽게 하고 소프트웨어 개발과 보수를 간편하게 하며, 보다 직관적인 코드 분석을 가능하게 하는장점을 갖고 있다. 그러나 지나친 프로그램의 객체화 경향은 실제 세계의 모습을 그대로 반영하지 못한다는 비판을 받기도 한다.



**2. 운영체제에 독립적**

-자바 응용프로그램은 운영체제나 하드웨어가 아닌 1JVM하고만 통신하고 JVM이 자바 응용프로그램으로부터 전달받은 명령을 해당 운영체제가 이해할수 있도록 변환하여 전달한다. 그래서 자바로 작성된 프로그램은 운영체제와 하드웨어에 관계없이 실행 가능하며 이것을 '한번 작성하면, 어디에서나 실행된다.(Write once, run anywhere)'고 표현 하기도한다.

 

**3.자동 메모리 관리(Garbage Collection)**

-Garbage Collector가 자동으로 메모리 관리를 해주기 때문에 프로그래머는 따로 메모리를 관리 하지 않아도 된다.

-자동 메모리 관리는 다소 비효율적인 면도 있지만, 프로그래머가 보다 프로그래밍에 집중할 수 있도록 도와준다.





**4.배우기 쉽다(단순함)**

-자바는 c/c++언어에서 연산자와 구문 구조를, 객체지향 관련 구문은 small talk(객체지향언어)에서 가져왔으며, 이들 언어의 장점은 취하고 단점은 과감히 버림으로써 간단명료한 코드를 작성하게 되었다.

 

**5. 다중 쓰레드를 제공**

-다중 쓰레드는 하나의 프로그램이 동시에 하나 이상의 처리(process)를 수행하는 것을 의미한다. 다중 쓰레드는 우리의 실생활과 유사하다. 사람을 하나의 객체로 본다면 TV를 보면서 햄버거를 먹는 일이 다중 쓰레드다. 자바는 사용자가 쓰레드를 편리하게 작성하여 사용할 수 있도록 쓰레드와 관련되 라이브러리 클래스를 제공하고 있고 JVM은 다중 쓰레드를 동시에 처리한다.

-일반적으로 자바로 작성된 Application은 여러 개의 클래스로 구성되어 있다. 자바는 다이나믹 로딩을 지원하기 때문에 실행시 모든 클래스가 로딩되지 않고 필요한 시점에 클래스를 로딩하여 사용할 수 있다.





**자바의 단점**

 

**1. 속도가 느림**

-자바는 하드웨어에 맞게 완전히 컴파일된 상태가 아니고, 실행시에 해석(Interpret)되기 떄문에 속도가 느리다는 단점을 가지고 있다.

그러나, 바이트코드(byte code)를 하드웨어의 기계어로 변환해주는 JIT컴파일러와 Hotspot(향상된 최적화 기술)과 같은 기술 적용으로 JVM 기능이 향상되어 속도문제가 상당히 개선되었다.



**2.불편한 예외처리**

-프로그램을 돌리다가 프로그램이 의도된대로 동작하지 않는 상황에서 예외를 발생시켜 처리를 할 수 있다. 대부분의 언어에서 차용하고 있는 좋은 기능이지만... 유독 Java는 다른 언어와는 달리 프로그래머 검사가 필요한 예외가 등장한다면 무조건 프로그래머가 선언을 해줘야 한다. 그렇지 않으면 컴파일조차 거부한다.

-Java에서 제공하는 Iterator 인터페이스에는 throws 선언 따위는 없기 때문에 Iterator를 구현받았을 때 명시적으로 예외를 던질 수 없다. 이 상황을 해결하려면 RuntimeException 계열을 쓸 수밖에 없는 상황이 펼쳐진다.

**[출처]** [Java란?(자바의 장점,단점)](http://blog.naver.com/jinpyo0311/220471091904)|**작성자** [홍삼](http://blog.naver.com/jinpyo0311







### 파이썬

1. 파이썬은 인터프리터 언어이다.

파이썬은 객체지향 기능을 강력히 지원하는 인터프리터언어 이다.

컴파일하고 실행해보고 잘못된부분을 고치는 기존절차에 벗어나 작성한 다음

바로 테스트해볼수있는게 아주 매력적이다.



2. 파이썬은 간단하다.

초보자들도 쉽게 배울수있다.

C언어를 배웠던 사람이라면 더욱쉽게 말이다.



3.파이썬은 강력하다.

이미 다른개발자들이 만든 라이브러리가 아주 대단하다.



4. 파이썬은 이식성이 좋다.

리눅스나 맥에서 사용가능하다.

등등 다른언어와 연동해서 사용할수있다.

특히 C언어는 잘된다.



\5. 파이썬은 개발속도가 빠르다.

문법이 간단하고 라이브러리를 사용하면

엄청빠를수밖에 없는것 같다.





파이썬 단점.

1. 파이썬은 계산에 약하다.

파이썬은 연산작업에서 불리합니다.

실험 결과도있다.

파이썬은 C언어보다 약40배정도 느리다고 한다.

하지만 pypy를 쓰면

약2배~3배로 줄어든다.

그래도 C언어보단 느리다.)



### **  C#의 장점**

﻿**첫째, 뛰어난 생산성입니다**.

수 많은 라이브러리와 IDE가 프로그래머가 손쉽게 코딩을 할 수 있게 도와주죠.

**둘째, 프로그래밍 입문자에게는 생산성이 뛰어나 프로그래밍에 대한 흥미를 깨우쳐 줄 것입니다.**

쉬운 생산성을 통해, 여러 프로그램을 만들어보며 우리는 프로그래밍의 재미를 알게 될 것입니다.

**샛째, 엄격한 문법입니다.**

사소한 실수부터 모든지 컴파일 에러를 띄우죠, 이런 엄격함덕분에 암묵적 에러를 방지 할 수 있습니다.

**넷째, 완벽한 프로그래밍입니다.**

C#에서 전역변수나 전역함수는 상상도 할 수 없는일이며, 모든 변수와 함수를 클래스에 넣어야합니다.

**다섯번째, 메모리 관리입니다.**

할당된 메모리를 해제하지 않아도 되며, 사용된 객체는 저절로 제거됩니다, 메모리 누수 걱정없어요!



**4 > 단점**

﻿**속도**입니다, C나 C++과 달리 C# .NET FRAMEWORK(가상머신)을 통해 실행이 되어 실행과정은 C나 C++이 더 심플하죠.



### **1. 코틀린의 장점**



1-1. 코틀린은 실용적이다

코틀린은 개발자들이 직면한 문제들을 해결할 수 있는 능력이 있다. 예를 들면 코틀린 타입 시스템을 사용하면 자바의 가장 흔한 에러인 NullPointerExceptions 에서 자유로울수 있다.

또한 자바의 불편한점을 개선하여 getter/setter의 번거로움을 줄여주고 함수를 class 밖에서 선언할 수 있는 등 편리성과 자유도도 제공한다.



1-2. 코틀린은 경제적이다.

코틀린은 오픈소스이다. 또한 기존의 자바 프레임워크와 라이브러리를 사용할 수 있는 등 자바와 

호환되어 사용될 수 있다. 따라서 현재 Android API들을 그대로 사용할 수 있고, Maven, Gradle과 같은 빌드 시스템도 사용할 수 있으며 추가적인 개발비용이 들지 않는다.



1-3. 코틀린은 쉽다.

코틀린의 문법은 이해하기 쉽고 독창적이어서 초보자들도 쉽고 빠르게 학습할 수 있다.

얼핏 보면 코틀린은 스칼라와 비슷한 것처럼 보이지만, 스칼라 보다 훨씬 더 단순할 뿐마나 아니라 문법의 간결성과 가독성의 균형 또한 잘 맞추고 있다.



1-4. 코틀린은 간결하다.

당신이 반복되는 문법을 사용하며 안드로이드용 프로그래밍을 할 때, 장황한 코드의 사용은 버그의 발생 빈도를 높인다. 이와는 반대로 간결한 문법을 가지고 있는 코틀린과 같은 언어를 사용하게 되면 버그의 발생 횟수를 줄일 뿐만 아니라, 덜 지루하게 개발이 가능하다.



1-5. 코틀린은 앙꼬 라이브러리를 사용한다.

앙꼬 라이브러리는 코틀린의 소스 파일 중 하나인데, 앙꼬 라이브러리의 주된 역할은

XML[extensible markup language] 관련된 문제들을 해결해 주는 것이다. 즉, 코드를 깨끗하고 읽기 쉽도록 만들어 안드로이드 애플리케이션 개발을 보다 빠르고 쉽게 할 수 있도록 도와주는 역할을 한다.



XML은 인터넷 웹페이지를 만드는 HTML을 획기적으로 개선하여 만든 언어로, 이로 인해 홈페이지 구축 기능, 검색 기능 등이 향상되었고, 웹 페이지의 추가 작성이 편리해졌다.







**2. 코틀린의 단점.**



2-1. 코틀린은 아직 앨리어스가 없다. 따라서 함수 유형을 매번 중복해서 작성해야 한다는 번거로움이 존재.



2-2. 코틀린은 자바 6 바이트코드를 대상으로 하기 때문에, 자바 8의 향상된 기능들을 제공하지 않는다. 또한 코틀린이 가지고 있는 사소한 문제 중 하나는 코틀린 표준 라이브러리가 자바 8 표준 라이브러리의 기능을 중복해 제공한다는 것.





2-3. 인텔리 J 내부의 컴파일은 점진적이며 자바만큼 빠르지만, 그래들을 Gradle을 통한 컴파일은 점진적이지 않기 때문에 속도가 느리다는 단점이 있다.



컴퓨터 운영 체계와 프로그램 언어에서의 **앨리어스**는, 이미 정의된 데이터 오브젝트에 대해 좀 더 이해하기 쉽고, 보다 의미 있게 붙인 이름을 말한다.

 **인텔리 J** 아이디어는 JetBrains 사에서 제작한 상용 자바 통합 개발 환경이다. 줄여서 인텔리 J 혹은

아이디어로도 불린다.

 **Gradle**은 Groovy를 이용한 빌드 시스템이다. Groovy와 유사한 도메인 언어를 채용하였으며, 현재 안드로이드 앱을 만드는데 필요한 안드로이드 슈튜디오의 공식 빌드 시스템이기도 하다. 자바, C/C++, 파이썬, 코틀린 등과 같은 여러가지 언어를 지원한다.

출처: 

http://mindols.tistory.com/93

 [교실]





Python - pandas

R -  패키지 다루는 것 dplyr / 데이터 시각화 ggplot2





### **R의 장단점**

**장점 1 : 데이터 시각화**
시각화된 데이터는  Raw 데이터 보다 훨씬 효과적으로 그 의도를 전달할 수 있습니다. R을 처음 만든 목적 자체가 ‘데이터 분석, 통계학 그리고 **시각화**를 하기 위해 더 좋고 친근한 방법을 만들어 보자!**‘**입니다. 그만큼 R은 강력한 데이터 시각화 기능을 자랑하죠. 의미 전달이나 보고가 목적이라면 R을 활용하세요. 대표적인 시각화 패키지에는 ggplot2, ggvis, googleVis, rCharts등이 있습니다.

**장점 2: 생태계**
R은 정말 풍부한 최첨단 패키지와 활발한 커뮤니티를 자랑합니다. 말 그대로 ‘R의 생태계’를 이루고 있죠. R 함수와 데이터들의 모음인 패키지, 이를 통해서 언제나 쉽게 최근의 테크닉과 기능에 접근할 수 있습니다. 자료를 찾느라 밤을 지새우지 않아도 되는 거죠!

**장점 3: 데이터 사이언스의 통용어**
R은 통계학자들에 의해, 통계학을 위해 개발되었습니다. 그래서 통계학자들은 그들의 아이디어와 개념들을 R의 코드와 패키지 등을 통해 공유하죠. 그래서 R을 활용한다면 데이터 사이언스를 시작하기 위해 꼭 컴퓨터 공학을 배워야 할 필요가 없습니다!



**단점 1: 느린 속도**
말씀드렸듯이 R은 통계학자들이 좀 더 쉽게 연구하려고 만든 언어이기에 컴퓨터를 효율적으로 활용하는 방법은 그리 깊게 고려하지 않은듯합니다. 다시 말해 R은 읽기 어려운 코드 때문에 좀 느릴 수 있습니다. 하지만 그런 단점을 상쇄해줄 수 있는 pqR, renjin, FastR, Riposte 등의 패키지가 있죠! R의 패키지 생태계는 정말 대단하네요.

**단점 2: 어렵다**
R을 배우는 것은 그리 쉬운 일이 아닙니다. 풍부한 패키지가 있지만 그걸 사용하는데 익숙하지 않다면 활용하는데 시간이 꽤 오래 걸릴 겁니다. 입문자가 처음부터 R을 활용해 원하는 분석을 할 수는 없습니다. 꾸준한 학습이 필요하죠.

![img](http://media.fastcampus.co.kr/wp-content/uploads/2017/01/pexels-photo-medium_2.jpg)

 

### 파이썬의 장단점

**장점 1:** **IPython Notebook**
IPython Notebook은 파이썬을 가지고 하는 데이터 작업을 훨씬 쉽게 만들어줍니다. 따로 부가적인 설치도 할 필요 없이, 동료들과 메모와 작업을 공유할 수 있습니다. 이를 통해 코드, 결과물, 메모 파일들을 정리하는데 필요한 비용을 획기적으로 줄여주죠. 진짜 해야 할 일에 집중할 수 있습니다.

**장점 2: 특정 주제나 용도에 국한되지 않은 배우기 쉬운 언어**
파이썬은 특정 분야를 위한 언어가 아니라 비교적 쉽고, 직관적입니다. 데이터 사이언스 말고도 다양한 분야에 많이 쓰이죠. 그만큼 배우기 쉽습니다. 코드를 익히고 쓰는데 드는 시간을 줄일 수 있습니다.

**장점 3: 다양한 용도의 언어**
파이썬은 다양한 백 그라운드의 사람들이 모두 사용할 수 있는 언어입니다. 이해하기 쉬운 언어이기 때문에 통계 백 그라운드를 가진 사람들도 배울 수 있죠. 워크플로우의 모든 부분을 통합시킬 하나의 도구를 만들 수도 있습니다.



**단점 1: 시각화**
R 에겐 장점이었던 것이 파이썬에겐 단점입니다! 시각화는 데이터 분석 소프트웨어를 고르는데 매우 중요한 판단 기준이지만, 아쉽게도 파이썬은 시각화 기능이 R에 비해 떨어지죠. Seaborn, Bokeh and Pygal과 같은 시각화 라이브러리를 가지고 있긴 하지만, 너무 선택사항이 많은 감이 들기도 합니다. 더욱이 R과 비교하면 파이썬의 시각화는 난해한 모습을 하고 있는 경우가 많습니다. 그래서 시각화된 결과가 썩 만족스럽지 않을 때도 있죠.

**단점 2: 파이썬은 도전자다**
데이터 분석 툴에 있어서 R이 파이썬보다 선구자입니다. 파이썬은 도전자죠. 그래서 R이 수백 개에 달하는 기본적인 패키지들의 대체자가 되기에는 아직 많이 부족합니다. 파이썬이 최근 핫하게 떠오르고는 있지만, 여전히 사람들이 방대한 패키지를 자랑하는 R을 포기할 만큼인지는 미지수입니다.







- ` 솔루션 이란 ? `  -  쇼핑몰을 만들고 운영할 수 있는 기능을 미리 만들어 두었다가 제공해 드리는 프로그램인데요. 이를 위해서 호스팅을 할당받고, 솔루션을 이용하여 쇼핑몰을 디자인하고 상품을 등록하는 등 운영 과정이 필요합니다.

` 웹호스팅서비스란  ? ` - 인터넷전용선과 서버를 구축하지 못한 분들을 위해서 인터넷망에 바로 연결되어 있는 서버의 일정공간을 임대하고 필요한 응용소프트웨어나 다양한 툴들을 제공하여 인터넷을 활용한 사업이나 여러 가지 목적으로 활용할 수 있는 웹사이트(홈페이지)를 제작할 수 있도록 하는 서비스입니다." 



- 

- `Backend 란 ? ` 프론트엔드에 보일 자료들을 만들어 내는 영역입니다. 자바, 파이썬, 루비 등의 언어나 스프링, 장고, 루비 온 레일스 같은 프레임워크 이름을 들어보셨다면, 그게 바로 이 영역입니다. 백엔드에서는 프론트엔드에 보여줄 HTML 문서를 그때그때 생성해서 내려줍니다.

`정적 페이지란 ? `  - 한번 작성하고 잘 바뀌지 않는 내용들은 평범한 파일의 형태로 디스크에 저장해뒀다가 전달해

` 동적페이지란 ?  ` - 그때그때 변하는 새로운 자료들은 요청시 클라이언트마다 다르게 만들어서 내려주고는 합니다. 



- `프론트엔드란 ?` 우리가 사용하는 웹브라우저가 이해하는 직접적인 기술들을 다루는 분야입니다. 웹브라우저들은 인터넷에서 문서를 받아와서 화면에 보이는데, 이 보이는 문서의 내용들이 들어있는 모양새라고 보시면 어떨까 합니다.

 

[Vue.js](https://vuejs.org/) 란? 보통의 웹사이트 처럼 간단한 화면 요소들만 필요할 것 같다면 [Vue.js](https://vuejs.org/)를 공부해서 씁시다.

- 흔히 보는 웹사이트들 보다 우아하고 현란하게 바뀔 내용이 많은 경우에는 [React.js](https://facebook.github.io/react/)를 공부해서 쓰기로 해요.
- [AngularJS](https://angularjs.org/)는 시작도 하지 말아요. 덩치 큰 괴물입니다.





- `MSA 마이크로 서비스 아키텍처 ` - 하나의 큰 애플리케이션을 여러 개의 작은 애플리케이션으로 쪼개어 변경과 조합이 가능하도록 만든 아키텍처를 말합니다. 애플리케이션을 특화된 기능별로 나누게 되면 자연스럽게 애플리케이션의 추상화(abstraction)가 가능해집니다



`모놀리틱 아키텍처` - 이러한 단순한 애플리케이션의 아키텍처는 서비스가 지속적으로 성장하고 규모가 커질 때 한계에 부딪히게 됩니다. 예를 들어, 3명의 개발자가 몇 가지 핵심 기능을 개발할 때에는 이와 같은 모놀리틱 아키텍처가 최적의 효율성을 보장하지만 개발자의 규모가 수십에서 백명 이상이 되고 서비스의 복잡도가 증가되면 아주 간단한 기능을 하나 추가하기 위해서도 매우 많은 줄의 코드를 수정해야함은 물론, 코드의 변화가 영향을 미치는 범위가 증가되었기 때문에 간단한 변화 하나에도 통합 테스트가 필요하게 됩니다.



- `OOP란` -    실세계의 사물을 추상화(Abstraction) 하고, 캡슐화(Encapsulation) 하며, 계층구조는 상속(Inheritance)시키며, 부모와 다른 자식의 특성, 행위는 다형성(Polymorphism) 으로 
  구현된 그것, 바로 객체의 구성으로 프로그램을 만들어 나가는 것을 객체지향 프로그래밍 이라 하는 것이죠.

**OOP**

1) 객체들이 서로 유기적으로 동작하는 프로그래밍 이론

2) 코드의 재사용성과 중복제거가 가장 큰 목적



**추상화**

1) 목적과 관련이 없는 부분을 제외해서 필요한 부분을 포착하는 기법

2) 객체의 공통된 속성들 중 필요한 부분을 포착해서 클래스로 정의하는 설계 기법



**캡슐화**

1) 외부에 노출될 필요가 없는 정보들은 숨기는 정보 은닉

2) 객체의 공통된 속성들을 클래스로 정의하는 것



**상속**

1) 상속 관계에 있는 두 클래스에 대해, 부모 클래스가 자손 클래스에게 속성을 물려주는 것

2) 코드의 재사용이 목적



**다형성**

1) 같은 형태이지만 다른 기능을 하는 것

2) 오버라이딩은 이와 관련된 기능임



- `git`  - git 을 통해 만들고 저장 

- Node.js/React/MongoDB 개발 경험자



`node.js`  - 중요한 이유는 이전까지 server-clint 웹사이트를 만들 때 웹에서 표시되는 부분은 javascript를 사용하여 만들어야만 했으며, 서버는 ruby, java 등 다른 언어를 써서 만들어야 했는데, 마침내 한가지 언어로 전체 웹페이지를 만들 수 있게 된 것입니다.

